<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 9.4.6 (461468)"/><meta name="author" content="NUMB"/><meta name="created" content="2020-11-15 14:52:49 +0000"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2021-01-10 11:46:34 +0000"/><title>Leetcode刷题笔记-剑指Offer（按分类）</title></head><body><h1>数组和字符串：</h1><ol><li><div>剑指 Offer 04. 二维数组中的查找</div></li><li><div>剑指 Offer 05. 替换空格</div></li><li><div>剑指 Offer 11. 旋转数组的最小数字</div></li><li><div><span style="--inversion-type-color:  simple; color: rgb(255, 4, 18);">剑指 Offer 17. 打印从 1 到最大的 n 位数</span></div></li><li><div>剑指 Offer 21. 调整数组顺序使奇数位于偶数前面</div></li><li><div>剑指 Offer 29. 顺时针打印矩阵</div></li><li><div>剑指 Offer 39. 数组中出现次数超过一半的数字</div></li><li><div>剑指 Offer 53 - I. 在排序数组中查找数字 I</div></li><li><div>剑指 Offer 57. 和为 s 的两个数字</div></li><li><div>剑指 Offer 57 - II. 和为 s 的连续正数序列</div></li><li><div>剑指 Offer 58 - I. 翻转单词顺序</div></li><li><div>剑指 Offer 58 - II. 左旋转字符串</div></li><li><div>剑指 Offer 66. 构建乘积数组</div></li></ol><div><br/></div><div><br/></div><hr/><div><br/></div><h1>剑指 Offer 04. 二维数组中的查找</h1><div><span style="background-color: rgb(219, 243, 205);">简单 </span>     标签：数组遍历</div><div><br/></div><h2>思路：</h2><div>从矩阵的左下角看，上方的数字都比其小，右方的数字都比其大，所以依据该规律去判断数字是否存在；</div><div>设当前数字为 cur，目标数字为 target，当 target &lt; cur 时，cur 更新为其上面的数字，当 target &gt; cur 时，cur 更新为其右侧的数字，直到相等则返回 true，否则到了矩阵边界返回 false</div><div>    </div><hr/><div><br/></div><h1>剑指 Offer 05. 替换空格</h1><div><span style="background-color: rgb(219, 243, 205);">简单 </span>     标签：string</div><div>请实现一个函数，把字符串 s 中的每个空格替换成"%20"。</div><div><br/></div><h2>思路：从后往前遍历数组，并且不需要开辟新的空间，而是直接在原数组上修改；best solution!</h2><div>参考题解：</div><div><a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/solution/mian-shi-ti-05-ti-huan-kong-ge-ji-jian-qing-xi-tu-/" rev="en_rl_none">https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/solution/mian-shi-ti-05-ti-huan-kong-ge-ji-jian-qing-xi-tu-/</a></div><div>算法流程：</div><div>初始化：空格数量 count ，字符串 s 的长度 len ；</div><div style="margin-top: 1em;margin-bottom: 1em;-en-paragraph:true;"><span style="-en-paragraph:true;">统计空格数量：遍历 s ，遇空格则 count++ ；</span></div><div style="margin-top: 1em;margin-bottom: 1em;-en-paragraph:true;"><span style="-en-paragraph:true;">修改 s 长度：添加完 "%20" 后的字符串长度应为 len + 2 * count ；</span></div><div style="margin-top: 1em;margin-bottom: 1em;-en-paragraph:true;"><span style="-en-paragraph:true;">倒序遍历修改：i 指向原字符串尾部元素， j 指向新字符串尾部元素；当 i = j 时跳出（代表左方已没有空格，无需继续遍历）；</span></div><div style="margin-top: 1em;margin-bottom: 1em;-en-paragraph:true;"><span style="-en-paragraph:true;">当 s[i] 不为空格时：执行 s[j] = s[i] ；</span></div><div style="margin-top: 1em;margin-bottom: 1em;-en-paragraph:true;"><span style="-en-paragraph:true;">当 s[i] 为空格时：将字符串闭区间 [j-2, j] 的元素修改为 "%20" ；由于修改了 3 个元素，因此需要 j -= 2 ；</span></div><div style="margin-top: 1em;margin-bottom: 1em;-en-paragraph:true;"><span style="-en-paragraph:true;">返回值：已修改的字符串 s；</span></div><div style="margin-top: 1em;margin-bottom: 1em;-en-paragraph:true;"><br/></div><div>注意：内存消耗较大；</div><div><br/></div><div><br/></div><hr/><div><br/></div><h1>剑指 Offer 11. <span style="font-size: 28px; --inversion-type-color:  simple; color: rgb(25, 25, 25);">旋转数组的最小数字</span></h1><div><span style="background-color: rgb(219, 243, 205);">简单 </span>     标签：二分法</div><div><span style="--inversion-type-color:  simple; color: rgb(25, 25, 25);">把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。  </span></div><div><br/></div><h2>思路：</h2><div><a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/solution/mian-shi-ti-11-xuan-zhuan-shu-zu-de-zui-xiao-shu-3/" style="--inversion-type-color:  simple;">https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/solution/mian-shi-ti-11-xuan-zhuan-shu-zu-de-zui-xiao-shu-3/</a></div><div>整体思路：首先数组是一个有序数组的旋转，从这个条件可以看出，数组是有大小规律的，可以使用二分查找利用存在的规律快速找出结果</div><div><br/></div><div>算法流程：</div><ol><li><div>初始化下标 left 和 right</div></li><li><div>每次计算中间下标 mid = (right + left) &gt;&gt;1，这里的除法是取整运算，不能出现小数</div></li><li><div>当 numbers[mid] &lt; numbers[right] 时，最小值在 [left, mid] 区间中，则令 right = mid，用于下一轮计算</div></li><li><div>当 numbers[mid] &gt; numbers[right] 时，最小值在 [mid, right] 区间中，则令 left = mid + 1，用于下一轮计算</div></li><li><div>当 numbers[mid] == numbers[right] 时，无法判断最小值在哪个区间之中，此时让 right--，缩小区间范围，在下一轮进行判断</div></li><li><div>为什么是 right-- 缩小范围，而不是 left++？<span style="font-size: unset; background-color: rgb(204, 204, 204); --inversion-type-background-color:  simple; font-family: unset;">因为数组是升序的，所以最小值一定靠近左侧，而不是右侧；</span><span style="font-size: unset; background-color: rgb(204, 204, 204); --inversion-type-background-color:  simple; font-family: unset;">比如，当存在 [1,2,2,2,2] 这种情况时，left = 0，right = 4，mid = 2，数值满足 numbers[mid] == numbers[right] 这个条件，如果 left++，则找不到最小值；</span></div></li></ol><div><br/></div><hr/><div> </div><h1><span style="--inversion-type-color:  simple; color: rgb(255, 4, 4);">剑指 Offer 17. </span><span style="font-size: 28px; --inversion-type-color:  simple; color: rgb(255, 4, 4);">打印从 1 到最大的 n 位数 </span></h1><div><span style="background-color: rgb(219, 243, 205);">简单 （并不）（这个题有东西）</span>     标签：数组</div><div><br/></div><h2>思路1：数组（不推荐！！）</h2><div>整体思路：首先求出要打印的数字范围，然后再从 1 开始打印到最大的数字</div><div><br/></div><div>算法流程：</div><ol><li><div>初始化 sum = 1</div></li><li><div>循环遍历乘 10 让 sum 变为边界值</div></li><li><div>新建 res 数组，大小为 sum-1</div></li><li><div>从 1 开始打印，直到 sum-1 为止</div></li></ol><div><br/></div><h2>思路2：字符串</h2><div>整体思路：<span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); color: rgb(89, 89, 89); font-family: Helvetica, arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">原题的题意其实是希望考察大数计算，因为 int 数组有可能会溢出，所以用字符串处理可以保证一定不会溢出；</span></div><div><a href="https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/solution/fei-zi-jie-ti-ku-jian-17-jian-dan-da-yin-cong-1dao/">https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/solution/fei-zi-jie-ti-ku-jian-17-jian-dan-da-yin-cong-1dao/</a></div><div><br/></div><div><br/></div><h2>思路3：递归</h2><div>整体思路：递归全排列解法。假设 n = 3，要输出的数其实就是三位数的全排列（000，001，002，...，999，当然 000 不能输出），我们用递归来表示出这个过程即可；</div><div><br/></div><hr/><div><br/></div><h1>剑指 Offer 21. <span style="font-size: 28px;">调整数组顺序使奇数位于偶数前面</span></h1><div><span style="background-color: rgb(219, 243, 205);">简单 </span>     标签：数组，双指针</div><div><br/></div><div>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。</div><div><br/></div><h2>思路1：数组（不推荐）</h2><div>整体思路：建2个数组，分别存放奇数，偶数；最后将偶数的数组插入奇数数组的后面；</div><div><br/></div><div>    </div><h2>思路2：双指针</h2><div>整体思路：前指针 i 和后指针 j，j指针遍历数组，若j指针指向奇数，则和i指针交换数值，则奇数在前面，此时i++；此时num[i]为偶数，等num[j]遍历到奇数，再进行交换；</div><div><br/></div><hr/><div><br/></div><h1>剑指 Offer 29. <span style="font-size: 28px;">顺时针打印矩阵</span></h1><div><span style="background-color: rgb(219, 243, 205);">简单 </span>       </div><div><br/></div><div>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</div><div><br/></div><div>思路：由题意，顺时针打印矩阵的顺序是 “从左向右、从上向下、从右向左、从下向上” 循环。所以，考虑设定矩阵的“左、上、右、下”四个边界，模拟以上矩阵遍历顺序。</div><div><br/></div><div>算法流程：</div><div>空值处理： 当 matrix 为空时，直接返回空列表 [] 即可。</div><div>初始化： 矩阵 左、右、上、下 四个边界 l , r , t , b ，用于打印的结果列表 res 。</div><div>循环打印： “从左向右、从上向下、从右向左、从下向上” 四个方向循环，每个方向打印中做以下三件事 ：</div><ol><li><div>根据边界打印，即将元素按顺序添加至列表 res 尾部；</div></li><li><div>边界向内收缩 1 （代表已被打印）；</div></li><li><div>判断是否打印完毕（边界是否相遇），若打印完毕则跳出。</div></li></ol><div>返回值： 返回 res 即可。</div><div><br/></div><div><img src="Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-%E5%89%91%E6%8C%87Offer%EF%BC%88%E6%8C%89%E5%88%86%E7%B1%BB%EF%BC%89.resources/E25745ED-AB43-431E-99D9-27011A9BAC4B.png" height="324" width="1248"/><br/></div><div><br/></div><div><br/></div><h1>剑指 Offer 39. <span style="font-size: 28px;">数组中出现次数超过一半的数字</span></h1><div><span style="background-color: rgb(219, 243, 205);">简单 </span>       标签：哈希表，摩尔投票</div><div><br/></div><div><span style="font-size: 13px; orphans: 2; widows: 2; background-color: rgb(204, 204, 204); --inversion-type-background-color:  simple; --inversion-type-color:  simple; color: rgb(5, 5, 5); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, Roboto, &quot;Helvetica Neue&quot;, Arial, &quot;Noto Sans&quot;, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;;">数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。</span></div><div style="box-sizing: border-box; font-size: 13px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); margin-top: 1em; margin-bottom: 1em;"><span style="box-sizing: border-box; font-size: 13px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); color: rgb(38, 38, 38); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, Roboto, &quot;Helvetica Neue&quot;, Arial, &quot;Noto Sans&quot;, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; font-variant-caps: normal; font-variant-ligatures: normal;-en-paragraph:true;">你可以假设数组是非空的，并且给定的数组总是存在多数元素。
</span></div><div><br/></div><h2>思路1：计数器遍历<span style="font-size: 21px;">（推荐）</span></h2><div>整体思路 ：设置一个计数器count，每遇到一个和当前的数字相同的数字，就让count自增，遇到一个和当前数字不一样的数字，就让count--，当count &lt; 0时，就将cur设置为当前遍历的数字。因为有一个数字出现次数超过数组长度的一半，最后得到的必然是该数字。</div><div><br/></div><h2>思路2：排序</h2><div>整体思路 ：先用sort()排序，再取中间值；</div><div><br/></div><h2>思路3：哈希表</h2><div>整体思路 ：利用 hashmap 储存数组中值的出现次数</div><div><br/></div><h2>思路4：<span style="font-size: 21px;">摩尔投票法（推荐）</span></h2><div>整体思路 ：先让 res = nums[0]，mole_vote = 0，然后往后迭代。但凡遇到下一个不等于 res，就让 mole_vote --（相当于和一个敌人同归于尽）；如果下一个等于 res，则mole_vote ++。如果 mole_vote == 0 了，就让 res 等于当前 numes[i]。</div><div><br/></div><div><img src="Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-%E5%89%91%E6%8C%87Offer%EF%BC%88%E6%8C%89%E5%88%86%E7%B1%BB%EF%BC%89.resources/%E6%88%AA%E5%B1%8F2020-11-24%20%E4%B8%8A%E5%8D%8812.22.10.png" height="698" width="926"/><br/></div><div><br/></div><div><br/></div><h1>剑指 Offer <span style="font-size: 28px;">53 - I. 在排序数组中查找数字 I</span></h1><div><span style="background-color: rgb(219, 243, 205);">简单 </span>       标签：二分法</div><div><br/></div><div><a href="https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/solution/mian-shi-ti-53-i-zai-pai-xu-shu-zu-zhong-cha-zha-5/">https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/solution/mian-shi-ti-53-i-zai-pai-xu-shu-zu-zhong-cha-zha-5/</a></div><div><img src="Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-%E5%89%91%E6%8C%87Offer%EF%BC%88%E6%8C%89%E5%88%86%E7%B1%BB%EF%BC%89.resources/12534C08-2F45-4B20-8501-64695044868D.png" height="576" width="782"/><br/></div><div><br/></div><div>整体思路：</div><div>初始化： 左边界 i=0 ，右边界 j = len(nums) - 1；</div><div>循环二分： 当闭区间 [i, j] 无元素时跳出；</div><div>计算中点 m = (i + j) / 2（向下取整）；</div><div>若 nums[m] &lt; target ，则 target在闭区间 [m + 1, j] 中，因此执行 i = m + 1；</div><div>若 nums[m] &gt; target ，则 target 在闭区间 [i, m - 1]中，因此执行 j = m - 1；</div><div>若 nums[m] = target，则右边界 right 在闭区间 [m+1, j]中；左边界 left 在闭区间 [[i,m−1] 中。因此分为以下两种情况：</div><div>    若查找 右边界 right ，则执行 i=m+1 ；（跳出时 i 指向右边界）</div><div>    若查找 左边界 left ，则执行 j = m - 1 ；（跳出时 j 指向左边界）</div><div>返回值： 应用两次二分，分别查找 right 和 left ，最终返回 right - left - 1 即可；</div><div><br/></div><div>注意⚠️：找到右边后，<span style="font-size: 14px; letter-spacing: -0.2px; orphans: 2; text-indent: 0px; text-transform: none; white-space: pre; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(247, 247, 247); color: rgb(0, 106, 0); font-family: monospace; font-variant-caps: normal; font-variant-ligatures: normal;">left为最右target的右边元素，right则应为最右边的target（若target存在）</span></div><div style="orphans: 2; widows: 2; "><span style="caret-color: rgb(202, 255, 202); letter-spacing: -0.20000000298023224px; white-space: pre; background-color: rgb(204, 204, 204); --inversion-type-background-color:  simple; --inversion-type-color:  simple; color: rgb(0, 53, 0); font-family: monospace;">需要判断：</span><span style="box-sizing: border-box; font-size: 14px; -webkit-print-color-adjust: exact; letter-spacing: -0.2px; orphans: 2; text-indent: 0px; text-transform: none; white-space: pre; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(247, 247, 247); color: rgb(170, 13, 145); font-family: monospace; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 19px;">if</span><span style="font-size: 14px; letter-spacing: -0.2px; orphans: 2; text-indent: 0px; text-transform: none; white-space: pre; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(247, 247, 247); color: rgb(89, 89, 89); font-family: monospace; font-variant-caps: normal; font-variant-ligatures: normal;">(</span><span style="box-sizing: border-box; font-size: 14px; -webkit-print-color-adjust: exact; letter-spacing: -0.2px; orphans: 2; text-indent: 0px; text-transform: none; white-space: pre; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(247, 247, 247); color: rgb(170, 13, 145); font-family: monospace; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 19px;">right</span> <span style="font-size: 14px; letter-spacing: -0.2px; orphans: 2; text-indent: 0px; text-transform: none; white-space: pre; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(247, 247, 247); color: rgb(89, 89, 89); font-family: monospace; font-variant-caps: normal; font-variant-ligatures: normal;">&gt;=</span> <span style="box-sizing: border-box; font-size: 14px; -webkit-print-color-adjust: exact; letter-spacing: -0.2px; orphans: 2; text-indent: 0px; text-transform: none; white-space: pre; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(247, 247, 247); color: rgb(28, 0, 207); font-family: monospace; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 19px;">0</span> <span style="font-size: 14px; letter-spacing: -0.2px; orphans: 2; text-indent: 0px; text-transform: none; white-space: pre; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(247, 247, 247); color: rgb(89, 89, 89); font-family: monospace; font-variant-caps: normal; font-variant-ligatures: normal;">&amp;&amp; nums[</span><span style="box-sizing: border-box; font-size: 14px; -webkit-print-color-adjust: exact; letter-spacing: -0.2px; orphans: 2; text-indent: 0px; text-transform: none; white-space: pre; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(247, 247, 247); color: rgb(170, 13, 145); font-family: monospace; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 19px;">right</span><span style="font-size: 14px; letter-spacing: -0.2px; orphans: 2; text-indent: 0px; text-transform: none; white-space: pre; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(247, 247, 247); color: rgb(89, 89, 89); font-family: monospace; font-variant-caps: normal; font-variant-ligatures: normal;">] != target) return 0</span></div><hr/><div style="orphans: 2; widows: 2; "><span style="font-size: 14px; letter-spacing: -0.2px; orphans: 2; text-indent: 0px; text-transform: none; white-space: pre; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(247, 247, 247);"><br/></span></div><div style="orphans: 2; widows: 2; "/><h1>剑指 Offer <span style="font-size: 28px;">57. 和为s的两个数字</span></h1><div style="orphans: 2; widows: 2; "><span style="background-color: rgb(219, 243, 205);">简单 </span>   标签：双指针，哈希表</div><div style="orphans: 2; widows: 2; "><br/></div><div style="orphans: 2; widows: 2; "/><h2>思路1：双指针</h2><div style="orphans: 2; widows: 2; ">整体思路：已知递增数组，我们通过前后2个指针，取先后的数之和，如果大了，那么需要后指针往前调整，如果小了，则需要左指针往后调整。如果相等，则push_back对应的值；</div><div style="orphans: 2; widows: 2; "><br/></div><div style="orphans: 2; widows: 2; "/><h2>思路2：哈希表（TO BE DONE）</h2><div style="orphans: 2; widows: 2; "><span style="orphans: 2; widows: 2;">整体思路：</span></div><div style="orphans: 2; widows: 2; "/><hr/><div style="orphans: 2; widows: 2; "/><div style="orphans: 2; widows: 2; "/><h1>剑指 Offer <span style="font-size: 28px;">57 - II. 和为s的连续正数序列</span></h1><div style="orphans: 2; widows: 2; "><span style="orphans: 2; widows: 2; background-color: rgb(219, 243, 205);">简单 </span><span style="orphans: 2; widows: 2;">   标签：双指针，时间窗口</span></div><div style="orphans: 2; widows: 2; "/><div style="orphans: 2; widows: 2; ">输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。 序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。 </div><div style="orphans: 2; widows: 2; "><br/></div><div style="orphans: 2; widows: 2; ">参考： <a href="https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/solution/shi-yao-shi-hua-dong-chuang-kou-yi-ji-ru-he-yong-h/">https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/solution/shi-yao-shi-hua-dong-chuang-kou-yi-ji-ru-he-yong-h/</a></div><div style="orphans: 2; widows: 2; "><br/></div><div style="orphans: 2; widows: 2; ">整体思路：滑动窗口，设立左右指针，从开始位置维护一个子数组作为窗口，判断该窗口是否求和为 target，如果是则将结果加入，如果小于 target 则窗口右移，大于 target 则窗口左移；</div><div style="orphans: 2; widows: 2; "><br/></div><div>首先初始化窗口，left=1 和 right=2</div><div>当 left &lt; right 时始终维护该窗口，只有当到达边界位置时，窗口和 sum &gt; target，left 始终右移，才会结束窗口维护；</div><div>根据求和公式 sum=(left+right)∗(right−left+1)/2 可以直接算出滑动窗口和；</div><div>当 sum == target 时，将窗口放入结果数组中；</div><div>当 sum &lt; target 时，说明窗口结果需要变大，right++</div><div>当 sum &gt; target 时，说明窗口结果需要变小，left++</div><div><br/></div><hr/><div style="orphans: 2; widows: 2; "><br/></div><div style="orphans: 2; widows: 2; "><br/></div><div style="orphans: 2; widows: 2; "/><h1><span style="font-size: 28px;">剑指 Offer 58 - I. 翻转单词顺序</span></h1><div style="orphans: 2; widows: 2; "><span style="orphans: 2; widows: 2; background-color: rgb(219, 243, 205);">简单 </span><span style="orphans: 2; widows: 2;">   标签：字符串</span></div><div style="orphans: 2; widows: 2; "/><div><br/></div><div>思路：从左向右扫描，取出单词，反转单词，拼接成结果串。</div><div>单词全部提取完成后。</div><div>反转结果串就是解。</div><div><br/></div><div>例如："the sky is blue"</div><div>提取单词的结果串："eht yks si eulb"</div><div>反转结果串："blue is sky the"</div><div style="orphans: 2; widows: 2; "/><div style="orphans: 2; widows: 2; ">使用函数：string.substr(I,j) : 从第I个元素开始，忘后提取j个元素；reverse(begin, end)：反转；</div><div style="orphans: 2; widows: 2; "><br/></div><div style="orphans: 2; widows: 2; ">字符串总结：<a href="https://mp.weixin.qq.com/s/gtycjyDtblmytvBRFlCZJg">https://mp.weixin.qq.com/s/gtycjyDtblmytvBRFlCZJg</a></div><div style="orphans: 2; widows: 2; ">尽量不要调用substr之内的函数，后面2刷时候需要注意！</div><div style="orphans: 2; widows: 2; "><br/></div><hr/><div style="orphans: 2; widows: 2; "><br/></div><div style="orphans: 2; widows: 2; "/><h1><span style="font-size: 28px;">剑指 Offer 58 - II. 左旋转字符串</span></h1><div style="orphans: 2; widows: 2; "><span style="orphans: 2; widows: 2; background-color: rgb(219, 243, 205);">简单 </span><span style="orphans: 2; widows: 2;">   标签：原地反转</span></div><div style="orphans: 2; widows: 2; "/><div style="orphans: 2; widows: 2; "/><h2>思路1：原地反转</h2><div style="orphans: 2; widows: 2; "><span style="orphans: 2; widows: 2;">整体思路：</span></div><ol style="box-sizing: border-box; font-size: 16px; -webkit-print-color-adjust: exact; padding-left: 16px; letter-spacing: normal; orphans: 2; text-align: justify; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><li style="box-sizing: border-box; font-size: 16px; -webkit-print-color-adjust: exact;"><div><span style="font-size: 16px; color: rgb(38, 38, 38); font-family: Helvetica, arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 25.92px;">反转区间为前n的子串</span></div></li><li style="box-sizing: border-box; font-size: 16px; -webkit-print-color-adjust: exact;"><div><span style="font-size: 16px; color: rgb(38, 38, 38); font-family: Helvetica, arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 25.92px;">反转区间为n到末尾的子串</span></div></li><li style="box-sizing: border-box; font-size: 16px; -webkit-print-color-adjust: exact;"><div><span style="font-size: 16px; color: rgb(38, 38, 38); font-family: Helvetica, arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 25.92px;">反转整个字符串</span></div></li></ol><div><span style="font-size: 16px; --inversion-type-color:  simple;"><br/></span></div><h2>思路2：切片</h2><div style="orphans: 2; widows: 2;"><span style="orphans: 2; widows: 2;">整体思路：新建个字符串，切片后，两次for循环，填充该字符串；</span></div><div style="orphans: 2; widows: 2; "/><div style="orphans: 2; widows: 2; "><br/></div><div style="orphans: 2; widows: 2; "><br/></div><hr/><div style="orphans: 2; widows: 2; "><br/></div><div style="orphans: 2; widows: 2; "/><h1><span style="font-size: 28px;">剑指 Offer 66. 构建乘积数组(待二刷)</span></h1><div style="orphans: 2; widows: 2; "><span style="--inversion-type-color:  simple; color: rgb(239, 158, 25);">中等</span>   标签：</div><div style="orphans: 2; widows: 2; "><br/></div><div>给定一个数组 A[0,1,…,n-1]，请构建一个数组 B[0,1,…,n-1]，其中 B 中的元素 B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]。不能使用除法。</div><div><br/></div><div style="orphans: 2; widows: 2; ">思路：</div><div style="orphans: 2; widows: 2; "> B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1] = {A[0]×A[1]×…×A[i-1]}  × 1 × {A[i+1]×…×A[n-1] }</div><div style="orphans: 2; widows: 2; ">建立两个数组：C[i]和D[i]，分别保存前后两个乘积的结果；所以：B[i] = C[i] × D[i]</div><div style="orphans: 2; widows: 2; "><br/></div><div style="orphans: 2; widows: 2; "><img src="Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-%E5%89%91%E6%8C%87Offer%EF%BC%88%E6%8C%89%E5%88%86%E7%B1%BB%EF%BC%89.resources/4468E596-138F-4616-8095-0A93CF0215DB.png" height="528" width="708"/><br/></div><div style="orphans: 2; widows: 2; ">找规律：c[n]=c[n-1]*a[n-1]，d[n]=d[n+1]a[n+1]，也就是上一次结果a的值然后两个值相乘，得到b[n]；</div><div style="orphans: 2; widows: 2; "><br/></div><div style="orphans: 2; widows: 2; "><img src="Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-%E5%89%91%E6%8C%87Offer%EF%BC%88%E6%8C%89%E5%88%86%E7%B1%BB%EF%BC%89.resources/40C50836-D16F-424A-9E2E-E77B363C93A6.png" height="626" width="1098"/><br/></div><div style="orphans: 2; widows: 2; "><img src="Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-%E5%89%91%E6%8C%87Offer%EF%BC%88%E6%8C%89%E5%88%86%E7%B1%BB%EF%BC%89.resources/A38A48AD-9B55-4038-B671-838C08366A68.png" height="644" width="1124"/><br/></div><div style="orphans: 2; widows: 2; "><br/></div><hr/><div style="orphans: 2; widows: 2; "/><h1>栈和队列：</h1><ol><li><div>剑指 Offer 06. 从尾到头打印链表</div></li><li><div>剑指 Offer 09. 用两个栈实现队列</div></li><li><div>剑指 Offer 30. 包含 min 函数的栈</div></li><li><div>剑指 Offer 59 - I. 滑动窗口的最大值</div></li><li><div>剑指 Offer 59 - II. 队列的最大值</div></li></ol><div><br/></div><hr/><div style="orphans: 2; widows: 2; "/><h1><span style="font-size: 28px;">剑指 Offer 06. </span><span style="font-size: 28px;">从尾到头打印链表</span></h1><div style="orphans: 2; widows: 2; "><span style="orphans: 2; widows: 2; background-color: rgb(219, 243, 205);">简单 </span><span style="orphans: 2; widows: 2;">  标签：栈表，递归</span></div><div style="orphans: 2; widows: 2; "><br/></div><div style="orphans: 2; widows: 2; ">输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</div><div style="orphans: 2; widows: 2; "><br/></div><div style="orphans: 2; widows: 2; "/><h2>思路1：<span style="orphans: 2; widows: 2;">栈表</span></h2><div style="orphans: 2; widows: 2; "><span style="orphans: 2; widows: 2;">整体思路：新建栈表保存数据，然后保存在数组，最后pop()</span></div><div style="orphans: 2; widows: 2; "/><div style="orphans: 2; widows: 2; "/><div style="orphans: 2; widows: 2; "/><h2 style="orphans: 2; widows: 2; ">思路2：递归</h2><div style="orphans: 2; widows: 2; "><span style="orphans: 2; widows: 2;">整体思路：</span></div><div style="orphans: 2; widows: 2; "><span style="orphans: 2; widows: 2;">/*</span></div><div>vector&lt;int&gt; res;</div><div>vector&lt;int&gt; reversePrint(ListNode* head) {</div><div>    if (!head) return res;</div><div>    reversePrint(head-&gt;next);</div><div>    res.push_back(head-&gt;val);</div><div>    return res;</div><div>    }</div><div>*/</div><div style="orphans: 2; widows: 2; ">⚠️：时间复杂度和空间复杂度都比前面高, think about it.</div><div style="orphans: 2; widows: 2; "><br/></div><hr/><h1><span style="font-size: 28px;">剑指 Offer 09</span><span style="font-size: 28px;">. 用两个栈实现队列</span></h1><div style="orphans: 2; widows: 2;"><span style="orphans: 2; widows: 2; background-color: rgb(219, 243, 205);">简单 </span><span style="orphans: 2; widows: 2;">  标签：栈表</span></div><div style="orphans: 2; widows: 2;"/><div style="orphans: 2; widows: 2;">用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 ) </div><div style="orphans: 2; widows: 2;"><br/></div><div style="orphans: 2; widows: 2;"><span style="orphans: 2; widows: 2;">整体思路：queue弹出的元素，是stack下面的元素，也是stack2上面的元素；如果stack2非空，弹出上面元素；如果stack2空了，stck1非空，将stack1元素压入srack2，再弹出最上面元素；如果两个stack都空，弹出-1；</span></div><div style="orphans: 2; widows: 2;"/><div style="orphans: 2; widows: 2;"/><div style="orphans: 2; widows: 2;"/><h2 style="orphans: 2; widows: 2;"><span style="orphans: 2; widows: 2;">只要添加元素，就在stack1中添加；只要删除元素，就在stack2栈顶中删；删除元素中，stack2为空，则将stack1元素全部倒入stack2，再从stack2删除栈顶元素！</span></h2><hr/><h1><span style="font-size: 28px;">剑指 Offer 30</span><span style="font-size: 28px;">. 用两个栈实现队列</span></h1><div style="orphans: 2; widows: 2;"><span style="orphans: 2; widows: 2; background-color: rgb(219, 243, 205);">简单 </span><span style="orphans: 2; widows: 2;">  标签：栈表</span></div><div style="orphans: 2; widows: 2;"><span style="orphans: 2; widows: 2;">用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 ) </span></div><div style="orphans: 2; widows: 2;"/><div style="orphans: 2; widows: 2;"/><h2 style="orphans: 2; widows: 2;"><span style="orphans: 2; widows: 2;">思路：辅助栈</span></h2><div style="orphans: 2; widows: 2;">对于取最小值 min 函数需要建立辅助栈，辅助栈中降序存储 push 进来的的值；时间复杂度：O(1)，空间复杂度：O(n)；</div><div style="orphans: 2; widows: 2;"><br/></div><div style="orphans: 2; widows: 2;">算法流程：</div><ol><li><div style="orphans: 2; widows: 2;">初始化数据栈data和辅助栈help；</div></li><li><div style="orphans: 2; widows: 2;">push(): data直接push；如果x值小于help.top()，则直接push，否则再将help.top()重新push一遍；（help数据量和data保持一致）</div></li><li><div style="orphans: 2; widows: 2;">Pop(): data和help都非空，则直接pop；</div></li><li><div style="orphans: 2; widows: 2;">top(): 返回data.top()</div></li><li><div style="orphans: 2; widows: 2;">min(): 返回help.top()</div></li></ol><div style="orphans: 2; widows: 2;"/><hr/><div style="orphans: 2; widows: 2;"/><h1><span style="font-size: 28px;">剑指 Offer 59 - I. 滑动窗口的最大值</span></h1><div style="orphans: 2; widows: 2;"><span style="orphans: 2; widows: 2; background-color: rgb(219, 243, 205);">简单 </span><span style="orphans: 2; widows: 2;">  标签：队列</span></div><div style="orphans: 2; widows: 2;">给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。</div><div style="orphans: 2; widows: 2;"><br/></div><div style="orphans: 2; widows: 2;"/><h2 style="orphans: 2; widows: 2; ">思路1：暴力法</h2><div style="orphans: 2; widows: 2;">时间复杂度高！</div><div style="orphans: 2; widows: 2;"><br/></div><h2 style="orphans: 2; widows: 2;"><span style="orphans: 2; widows: 2;">思路2：单调队列</span></h2><div><img src="Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-%E5%89%91%E6%8C%87Offer%EF%BC%88%E6%8C%89%E5%88%86%E7%B1%BB%EF%BC%89.resources/3D1A7EEE-3AA9-4DCB-AAC1-7355CC4FE79D.png" height="754" width="970"/><br/></div><div><br/></div><div>遍历数组时，每轮保证单调队列 deque ：</div><ol><li><div> deque 内仅包含窗口内的元素 ⇒ 每轮窗口滑动移除了元素 nums[i - 1]，需将 deque 内的对应元素一起删除。 </div></li><li><div>deque 内的元素 非严格递减  ⇒ 每轮窗口滑动添加了元素 nums[j+1] ，需将 deque 内所有 小于 nums[j + 1]的元素删除。</div></li></ol><div><br/></div><div><br/></div><div>参考代码：</div><div>class Solution {</div><div>public:</div><div>    vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) {</div><div>        if(nums.size() == 0 || k == 0) return {};</div><div>        deque&lt;int&gt; dq;</div><div>        vector&lt;int&gt; res;</div><div>        for(int i = 1 - k, j = 0; j &lt; nums.size(); ++i, ++j)</div><div>        {</div><div>            // 如果 i &gt; 0 说明窗口已经在数组中了，并且单调队列的第一个元素和 nums[i - 1] 相等时，</div><div>            // 说明该元素已经不在滑动窗口中，需要移除</div><div>            if(i &gt; 0 &amp;&amp; dq.front() == nums[i-1]) dq.pop_front();</div><div>            // 如果单调队列不为空且最后一个元素小于新加入的 nums[j] 元素，则需要维护单调队列为递减状态，</div><div>            // 所以将最后一个元素移除，直到其大于新加入元素</div><div>            while(!dq.empty() &amp;&amp; dq.back() &lt; nums[j]) dq.pop_back();</div><div>            // 将新加入的 nums[j] 元素加入单调队列，因为上一步的操作，当前单调队列一定是递减的</div><div>            dq.push_back(nums[j]);</div><div>            // 如果 i &gt;= 0，说明窗口在数组中，因为单调队列递减，所以第一个元素一定是当前滑动窗口最大值</div><div>            if(i &gt;= 0) res.push_back(dq.front());</div><div>        }</div><div>        return res;</div><div>    }</div><div>};</div><div><br/></div><hr/><h1><span style="font-size: 28px;">剑指 Offer 59 - II. 队列的最大值</span></h1><div style="orphans: 2; widows: 2;"><span style="orphans: 2; widows: 2; background-color: rgb(219, 243, 205);">中等 </span><span style="orphans: 2; widows: 2;">  标签：</span>单调队列、辅助队列</div><div style="orphans: 2; widows: 2;"><br/></div><div style="orphans: 2; widows: 2;"/><h2 style="orphans: 2; widows: 2;"><span style="orphans: 2; widows: 2;">思路：辅助队列</span></h2><ol><li><div style="orphans: 2; widows: 2;"><span style="font-size: unset; background-color: rgb(204, 204, 204); --inversion-type-background-color:  simple; font-family: unset;">这道题和 59 - I 的思路很像，最难的地方在于取出最大值函数的时间复杂度如何降为 O(1)？如果每次入队的时候都维护一个最大值，那么时间复杂度很明显不满足条件。</span></div></li><li><div style="orphans: 2; widows: 2;"><span style="font-size: unset; background-color: rgb(204, 204, 204); --inversion-type-background-color:  simple; font-family: unset;">使用一个额外的辅助单调队列，该队列单调递减即可，保证最大值在队列头部，这样的话就可以在取出最大值的时候时间复杂度减低。</span></div></li></ol><div style="orphans: 2; widows: 2;"><br/></div><div style="orphans: 2; widows: 2;">参考代码：</div><div>class MaxQueue {</div><div>public:</div><div>    deque&lt;int&gt; dq;</div><div>    deque&lt;int&gt; help;</div><div>    MaxQueue() {</div><div>    }</div><div>    </div><div>    int max_value() {</div><div>        // 单调队列队首就是最大值</div><div>        return help.size() ? help.front() : -1;</div><div>    }</div><div>    </div><div>    void push_back(int value) {</div><div>        dq.push_back(value);</div><div>        // 将单调队列尾部所有小于该值的元素都剔除，最后将该值放入尾部，保证单调队列递减</div><div>        // “后浪”思想:如果之前入队的队尾比后入队的当前元素还要小，就让队尾出</div><div>        while(help.size() &amp;&amp; value &gt; help.back()) help.pop_back();</div><div>        help.push_back(value);</div><div>    }</div><div>    </div><div>    int pop_front() {</div><div>        if(dq.empty()) return -1;</div><div>        int frontValue = dq.front();</div><div>        dq.pop_front();</div><div>        // 当普通队列的队首元素等于单调队列队首就让单调队列队首出队</div><div>        if(help.size() &amp;&amp; help.front() == frontValue) help.pop_front();</div><div>        return frontValue;</div><div>    }</div><div style="orphans: 2; widows: 2;">};</div><div/><div style="orphans: 2; widows: 2;"/><div style="orphans: 2; widows: 2;"/><div style="orphans: 2; widows: 2;"/><div style="orphans: 2; widows: 2;"/><div style="orphans: 2; widows: 2;"/><div style="orphans: 2; widows: 2;"/><div style="orphans: 2; widows: 2;"/><div style="orphans: 2; widows: 2;"/><div style="orphans: 2; widows: 2;"/><div style="orphans: 2; widows: 2;"/><div style="orphans: 2; widows: 2;"/><div style="orphans: 2; widows: 2;"/><div style="orphans: 2; widows: 2;"/><div style="orphans: 2; widows: 2;"/><div style="orphans: 2; widows: 2;"/><div style="orphans: 2; widows: 2;"/><div style="orphans: 2; widows: 2;"/><div style="orphans: 2; widows: 2;"/><div style="orphans: 2; widows: 2;"/><div style="orphans: 2; widows: 2;"/><div style="orphans: 2; widows: 2;"/><div style="orphans: 2; widows: 2;"/><div style="orphans: 2; widows: 2;"/></body></html>